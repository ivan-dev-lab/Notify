Ниже — **ТЗ для Speculator** на определение **RB (Range Block)** в твоей системе:
RB = зона между **линией L под фракталом** и **уровнем фрактала (extreme)**. Это “родительская” область, из которой позже может формироваться SNR (через break+close и departure-экстремум).

---

# ТЗ: Определение RB (Range Block) в Speculator

## 1) Цель

Добавить в Speculator детектор и хранение **RB** на основе 3-свечных фракталов, чтобы:

* RB можно было визуализировать как прямоугольник (L ↔ extreme),
* RB мог выступать “источником” для последующего анализа/логики,
* RB можно было связать с SNR (через `origin_fractal_id`).

---

## 2) Определения

## 2.1. 3-свечной фрактал (pivot)

Для тройки свечей `C1, C2, C3`:

* **Fractal High** на `C2`, если
  `High(C2) > High(C1)` и `High(C2) > High(C3)`

* **Fractal Low** на `C2`, если
  `Low(C2) < Low(C1)` и `Low(C2) < Low(C3)`

Фрактал подтверждён после закрытия `C3`.

## 2.2. Линия L (“под фракталом”)

Линия L задаётся как:

* `L = Close(C1)`
  (эквивалентно `Open(C2)` на большинстве рынков; хранить как `l_price` и `l_alt_price`)

## 2.3. RB (Range Block)

RB — это **зона** между уровнем L и экстремумом фрактала:

* Для **Fractal High**:

  * `rb_low  = min(L, High(C2)) = L`
  * `rb_high = max(L, High(C2)) = High(C2)`

* Для **Fractal Low**:

  * `rb_low  = min(L, Low(C2)) = Low(C2)`
  * `rb_high = max(L, Low(C2)) = L`

Общее правило:

* `rb_low = min(l_price, extreme_price)`
* `rb_high = max(l_price, extreme_price)`

---

## 3) Входные данные

* Источник: MT5 исторические бары по TF
* Используемые поля: `time, open, high, low, close`
* Таймфреймы: `M15, H1, H4, D1, W1, MN1` (как в State)

---

## 4) Алгоритм детекции RB

## 4.1. На каждом TF

Идём по барам `i` и проверяем тройку:

* `C1 = bars[i-2]`
* `C2 = bars[i-1]`
* `C3 = bars[i]`

Если на `C2` подтвердился фрактал (high/low) — создаём RB.

## 4.2. Момент “формирования” RB

RB считается **сформированным** в момент подтверждения фрактала:

* `formation_time_utc = time(C3)` (или `confirm_time_utc`)
* `pivot_time_utc = time(C2)`

---

## 5) Структура RB-элемента (для хранения в State)

RB хранится в `State` как отдельный тип элемента: `element_type="rb"`.

Рекомендуемая схема:

```json id="k3l6gk"
{
  "id": "....",
  "element_type": "rb",
  "symbol": "SPX500",
  "timeframe": "H4",

  "rb_type": "high|low",                // от какого фрактала (Fractal High/Low)
  "origin_fractal_id": "....",          // ссылка на fractal element

  "pivot_time_utc": "2026-01-20T00:00:00Z",
  "confirm_time_utc": "2026-01-20T04:00:00Z",

  "c1_time_utc": "...",
  "c2_time_utc": "...",
  "c3_time_utc": "...",

  "l_price": 6865.57,
  "l_alt_price": 6865.60,

  "extreme_price": 6880.10,

  "rb_low": 6865.57,
  "rb_high": 6880.10,

  "status": "active|broken|expired",     // см. ниже
  "broken_time_utc": null,
  "broken_side": null,                  // "up"|"down" (опционально)

  "metadata": {}
}
```

---

## 6) Статусы RB (минимум)

RB сам по себе — статичный диапазон, но для практики полезно хранить его “живость”.

### 6.1. `active`

Сразу после создания.

### 6.2. `broken` (опционально, но полезно)

RB считается “сломленным”, если цена закрылась **за пределами** RB:

* `Close > rb_high` → `broken_side="up"`
* `Close < rb_low` → `broken_side="down"`

`broken_time_utc` — время бара, на котором произошёл пробой.

> Это не SNR, это именно “RB перестал быть диапазоном удержания”.
---

## 7) Правила ID (дедупликация)

RB должен иметь стабильный `id`:

Рекомендуется:
`id = sha1(symbol|timeframe|rb_type|pivot_time_utc|l_price|extreme_price)`

---

## 8) Интеграция в `State/<SYMBOL>.json`

В каждом TF добавить массив:

* `elements.rb: []`

```json id="b7z5o1"
"timeframes": {
  "H4": {
    ...
    "elements": {
      "fvg": [],
      "snr": [],
      "fractals": [],
      "rb": []
    }
  }
}
```

---

## 9) Инкрементальное обновление (как считать быстро)

### 9.1. Создание новых RB

Так как фрактал 3-свечной:

* новые RB могут появиться только при формировании нового бара, проверяя последние 3 свечи.

### 9.2. Обновление статуса `broken`

Для активных RB:

* достаточно проверять новый бар `Close` относительно `[rb_low, rb_high]`.
* если пробит → обновить `status/broken_time_utc/broken_side`.

---

## 10) Критерии готовности

1. На любом TF RB создаётся **строго при подтверждённом фрактале**.
2. `rb_low/rb_high` корректно равны диапазону между `L` и `extreme_price`.
3. RB не дублируются при повторных обновлениях (стабильный `id`).
4. (Если включено) статус `broken` выставляется корректно при закрытии выше/ниже RB.

---

## 11) Примечание по связи RB ↔ SNR

* RB — это “структура вокруг фрактала” (L ↔ pivot extreme).
* SNR — это “структура после возврата и закрепления” (L ↔ departure extreme).
  Поэтому:
* `origin_fractal_id` обязательно хранить и в RB, и в SNR (через фрактал).

---

Если хочешь, я добавлю к ТЗ ещё **правила визуализации** (время начала RB: pivot/confirm, время окончания: broken/now) и как RB использовать в логике построения сценариев (например, “вход только при ретесте RB внутри HTF bias”).
