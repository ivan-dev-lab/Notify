Ниже — **тех. задание (ТЗ)** на определение **3-свечных фракталов** и построение **SNR-зон** по твоей логике, плюс **структура хранения** в `output/Fractals` и `output/SNR` в стиле твоих `output/FVG/*.json`.

---

# ТЗ: Fractals (3 свечи) + SNR (зона на основе L и экстремума)

## 0) Термины и допущения

### Таймфреймы

Используются те же TF, что и у тебя в системе:
`M15, H1, H4, D1, W1, MN1`

### Свечи (OHLC)

Для расчётов используются OHLC-данные (из MT5).
Время свечи = время **открытия бара** (как в MT5 `rates[i].time`).

---

# 1) Модуль Fractals

## 1.1. Определение 3-свечного фрактала

Для тройки последовательных свечей `C1, C2, C3`:

* **Fractal High** на `C2`, если
  `High(C2) > High(C1)` **и** `High(C2) > High(C3)`

* **Fractal Low** на `C2`, если
  `Low(C2) < Low(C1)` **и** `Low(C2) < Low(C3)`

Фрактал считается **подтверждённым** только после закрытия `C3`.

## 1.2. Уровень L (линия фрактала)

По твоей формулировке:

* `L = Close(C1)` (и эквивалентно `Open(C2)` в большинстве FX случаев)
* В данных храним обе величины для прозрачности:

  * `l_price = Close(C1)`
  * `l_alt_price = Open(C2)` (для контроля гэпов/расхождений)

## 1.3. Выходные элементы (что сохраняем)

Каждый подтверждённый фрактал сохраняется как элемент.

### Поля элемента `fractal`

* `id` — стабильный ID (хэш)
* `element_type` = `"fractal"`
* `symbol`, `timeframe`
* `fractal_type` = `"high"` | `"low"`
* `pivot_time` — время свечи `C2`
* `confirm_time` — время свечи `C3` (момент, когда фрактал стал известен)
* `c1_time`, `c2_time`, `c3_time`
* `extreme_price` — `High(C2)` для high, `Low(C2)` для low
* `l_price` — `Close(C1)`
* `l_alt_price` — `Open(C2)`
* `metadata` — объект под расширения

### Правило ID

Рекомендуется:
`id = sha1(symbol|timeframe|fractal_type|pivot_time|extreme_price|l_price)`
(важно: **pivot_time** фиксирует фрактал однозначно).

---

# 2) Модуль SNR

## 2.1. Смысл SNR в твоей модели

SNR появляется **не в момент фрактала**, а после того как цена:

1. сформировала фрактал (и тем самым задала `L` и `extreme`)
2. ушла в сторону,
3. **вернулась**, **пробила уровень L** и **закрылась** по другую сторону (break + close)

После этого строится **SNR-зона** как диапазон между:

* `L` и `extreme` (экстремум фрактала)

То есть SNR — всегда **зона**, а не линия.

## 2.2. Активация SNR (break + close, без буферов)

Пусть есть фрактал с уровнем `L`.

### Break & Close вверх (закрылись выше L)

Событие `break_up_close` на свече `i`, если:

* `Close[i] > L`
* `Close[i-1] <= L`

Тогда SNR получает роль:

* `role = "support"` (бывшее сопротивление → поддержка)

### Break & Close вниз (закрылись ниже L)

Событие `break_down_close` на свече `i`, если:

* `Close[i] < L`
* `Close[i-1] >= L`

Тогда:

* `role = "resistance"`

## 2.3. Границы зоны

Для любых случаев:

* `snr_low  = min(L, extreme_price)`
* `snr_high = max(L, extreme_price)`

> Это снимает путаницу “что нижняя/верхняя граница”, а смысл (support/resistance) задаёт `role`.

## 2.4. Статусы SNR-зоны (минимум)

* `active` — зона создана (после break+close)
* `retested` — цена вернулась в зону хотя бы раз
* `invalidated` — зона перестала быть валидной (см. правило ниже)

### Ретест (простое правило по барам)

Зона считается ретестнутой на свече `i`, если диапазон пересёк зону:

* `High[i] >= snr_low` **и** `Low[i] <= snr_high`

### Инвалидация (опционально, но рекомендую фиксировать)

Без буферов:

* Если `role="support"` (зона поддержки после пробоя вверх):
  `invalidated`, если **закрылись ниже нижней границы**: `Close[i] < snr_low`

* Если `role="resistance"` (зона сопротивления после пробоя вниз):
  `invalidated`, если **закрылись выше верхней границы**: `Close[i] > snr_high`

даже если цена тенью задела 

## 2.5. Выходные элементы SNR

SNR сохраняется как отдельный элемент **только после активации** (после break+close).

### Поля элемента `snr`

* `id` — стабильный ID
* `element_type` = `"snr"`
* `symbol`, `timeframe`
* `origin_fractal_id` — ссылка на фрактал, который породил зону
* `role` = `"support"` | `"resistance"`
* `break_type` = `"break_up_close"` | `"break_down_close"`
* `break_time` — время свечи, на которой случился break+close
* `break_close` — Close этой свечи (для аудита)
* `l_price` — уровень L (из фрактала)
* `extreme_price` — экстремум фрактала
* `snr_low`, `snr_high`
* `status` = `active|retested|invalidated`
* `retest_time` (если был)
* `invalidated_time` (если было)
* `metadata` — под расширения (например, число касаний)

### Правило ID

Рекомендуется:
`id = sha1(symbol|timeframe|origin_fractal_id|break_time|role|snr_low|snr_high)`

---

# 3) Структура хранения файлов (в твоём стиле)

## 3.1. Пути

* Фракталы: `output/Fractals/<SYMBOL>.json`
* SNR: `output/SNR/<SYMBOL>.json`

## 3.2. Общий формат файла (как FVG)

Файлы Fractals и SNR повторяют структуру FVG:

```json
{
  "symbol": "EURGBP",
  "updated_at_utc": "2026-02-22T17:00:23.811611+00:00",
  "timeframes": {
    "M15": {
      "initialized": true,
      "updated_at_utc": "2026-02-22T17:00:23.811611+00:00",
      "last_bar_time": "2026-02-20T23:45:00+00:00",
      "elements": []
    }
  }
}
```

## 3.3. Fractals: элементы в `elements`

Пример элемента фрактала:

```json
{
  "id": "a1b2c3...",
  "element_type": "fractal",
  "symbol": "EURGBP",
  "timeframe": "M15",
  "fractal_type": "high",
  "pivot_time": "2026-02-20T10:30:00+00:00",
  "confirm_time": "2026-02-20T11:00:00+00:00",
  "c1_time": "2026-02-20T10:15:00+00:00",
  "c2_time": "2026-02-20T10:30:00+00:00",
  "c3_time": "2026-02-20T10:45:00+00:00",
  "extreme_price": 0.86812,
  "l_price": 0.86774,
  "l_alt_price": 0.86774,
  "metadata": {}
}
```

## 3.4. SNR: элементы в `elements`

Пример элемента SNR:

```json
{
  "id": "d4e5f6...",
  "element_type": "snr",
  "symbol": "EURGBP",
  "timeframe": "M15",
  "origin_fractal_id": "a1b2c3...",
  "role": "support",
  "break_type": "break_up_close",
  "break_time": "2026-02-21T09:45:00+00:00",
  "break_close": 0.86790,
  "l_price": 0.86774,
  "extreme_price": 0.86812,
  "snr_low": 0.86774,
  "snr_high": 0.86812,
  "status": "retested",
  "retest_time": "2026-02-21T12:15:00+00:00",
  "invalidated_time": null,
  "metadata": {}
}
```

---

# 4) Логика “сбор и актуализация” (для Fractals и SNR)

## 4.1. Первичная инициализация TF

Если `initialized=false` или файл пуст:

1. загрузить историю (минимум достаточно для фракталов/пробоев; рекомендую брать с буфером)
2. найти все подтверждённые фракталы → записать
3. построить SNR-зоны:

   * пройти по каждому фракталу и найти **первое** событие break+close через его `L`
   * если событие найдено → создать SNR
   * определить ретест/инвалидацию на последующих барах
4. сохранить файл

## 4.2. Инкрементальная актуализация (каждый запуск по расписанию TF)

**Fractals:**

* догрузить новые бары после `last_bar_time`
* проверить только последние 3 бара (т.к. фрактал 3-свечной подтверждается на правой свече)
* если найден новый подтверждённый фрактал → добавить в `elements`

**SNR:**

* для новых фракталов добавить их `origin_fractal_id` в “наблюдение”
* на новых барах проверять break+close по `L` для фракталов “в наблюдении”
* если break+close случился → создать новый SNR-элемент
* для активных SNR обновить статус (retested / invalidated)

## 4.3. Когда обновлять файл

Файл перезаписывается **только если**:

* добавлен новый элемент (фрактал или SNR), **или**
* изменился статус существующего SNR (например `active → retested`, `* → invalidated`), **или**
* обновились поля `last_bar_time/updated_at_utc`.

---

# 5) Рекомендованное доп. поле состояния (не ломает твой формат)

Чтобы SNR не сканировал каждый раз “все фракталы за всю историю”, можно добавить в объект TF поле `state`:

```json
"state": {
  "watched_fractal_ids": ["..."],
  "last_fractal_time_processed": "..."
}
```

Это **опционально**, но сильно помогает по скорости и детерминизму.

---

# 6) Acceptance Criteria (критерии готовности)

1. **Фракталы**:

* на тестовых данных корректно выделяются pivot high/low по строгим `>` / `<`
* новый фрактал появляется **только после** закрытия правой свечи

2. **SNR**:

* SNR создаётся **только после** break+close через `L`
* границы зоны корректны: `snr_low=min(L,extreme)`, `snr_high=max(...)`
* статус `retested` выставляется при первом пересечении зоны
* статус `invalidated` выставляется по правилу закрытия за границами зоны (если включено)

3. **Хранение**:

* формат файлов соответствует FVG-структуре
* нет дублей элементов при повторных апдейтах (стабильный `id`)