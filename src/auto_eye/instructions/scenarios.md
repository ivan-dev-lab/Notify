Ниже — **тех. задание** на реализацию модели **предложения сценариев** в Speculator по твоему описанию. Я формализовал термины, триггеры, вход/выход, статусы и правила поиска SL/TP. Если какие-то поля у тебя уже есть в `State` — отлично; если нет, ТЗ подсказывает, что добавить в derived/сервисные индексы.

---

# ТЗ: Speculator — генерация сценариев сделок по тренду, H1 неэффективностям и M5 подтверждениям

## 1) Цель

Сделать модуль, который для каждого актива:

1. определяет текущий **тренд** (по твоему правилу: только H1 FVG/SNR, RB не участвует),
2. отслеживает **трендовые неэффективности** на H1 (FVG/SNR в сторону тренда),
3. ждёт взаимодействия цены с этими элементами и подтверждения на M5 (FVG/SNR),
4. формирует **предложение сделки** (scenario) с:

   * Entry (логика входа — минимально: “по рынку/по зоне M5”),
   * SL “за трендовую неэффективность”,
   * TP до ближайшего H1 элемента из множества `{FVG, SNR, RB, fractal}`,
5. сохраняет предложения и историю взаимодействий в `Exchange`.

---

## 2) Источники данных и таймфреймы

### 2.1. Входные файлы

* `Exchange/State/<SYMBOL>.json` — элементы рынка:

  * H1: `fvg`, `snr`, `rb`, `fractals`
  * M5: `fvg`, `snr` *(и при необходимости `rb/fractals`, но MVP достаточно fvg/snr)*
* `Exchange/Trends/<SYMBOL>.json` — текущий тренд (из предыдущего ТЗ)

### 2.2. Таймфреймы, используемые в модели

* HTF для тренда и целей: **H1**
* LTF подтверждение: **M5**

---

## 3) Термины и классификация элементов

## 3.1. Тренд (trend)

* `bullish` / `bearish` / `neutral`
* определяется ТОЛЬКО по H1 **FVG/SNR**:

  * bullish ⇔ последний валидный сигнал `+H1 FVG (bullish)` или `+H1 SNR (support/break_up_close)`
  * bearish ⇔ последний валидный сигнал `-H1 FVG (bearish)` или `-H1 SNR (resistance/break_down_close)`
* **RB не является неэффективностью** и не участвует в определении тренда.

## 3.2. “Неэффективность” (inefficiency) на H1

Для данного ТЗ “неэффективности” для тренда = только:

* H1 FVG
* H1 SNR

RB и fractal — **элементы** (для TP/ориентиров), но не неэффективности.

## 3.3. Трендовая неэффективность (trend inefficiency)

Это H1 элемент, направленный “по тренду”:

* Если `trend=bullish`:

  * H1 FVG bullish = трендовая неэффективность
  * H1 SNR support / break_up_close = трендовая неэффективность

* Если `trend=bearish`:

  * H1 FVG bearish = трендовая неэффективность
  * H1 SNR resistance / break_down_close = трендовая неэффективность

## 3.4. Противоположный элемент по тренду на H1

Элемент, направленный “против тренда”:

* Если `trend=bullish`:

  * opposite = H1 FVG bearish или H1 SNR resistance

* Если `trend=bearish`:

  * opposite = H1 FVG bullish или H1 SNR support

---

## 4) Основные сценарии модели

## Сценарий A: “Продолжение тренда” (trend continuation)

**Условие:**

1. Есть `trend ∈ {bullish,bearish}`
2. На H1 существует трендовая неэффективность (H1 FVG/SNR по тренду)
3. Цена **взаимодействует** с этой H1 неэффективностью
4. На M5 появляется подтверждение: **M5 FVG или M5 SNR** в сторону тренда

**Действие:**
→ предложить сделку **в сторону тренда**

* SL: “за” трендовую неэффективность (см. раздел 6)
* TP: до ближайшего H1 элемента из `{FVG, SNR, RB, fractal}` (см. раздел 7)

---

## Сценарий B: “Разворот от противоположного элемента” (trend reversal at opposite)

**Условие:**

1. Есть `trend ∈ {bullish,bearish}`
2. Цена дошла до **противоположного элемента по тренду** на H1 (opposite FVG/SNR)
3. После этого на H1 **образуется противоположный (контртрендовый) элемент** из множества:

   * `H1 RB` или `H1 SNR` или `H1 FVG` (против тренда)
4. Затем цена реагирует на него на M5: появляется подтверждение **M5 FVG или M5 SNR** в сторону *контртренда* (т.е. против исходного тренда)

**Действие:**
→ предложить сделку **против тренда (контртренд)**

* SL: за “трендовую неэффективность” (уточнение ниже)
* TP: до ближайшего H1 элемента `{FVG, SNR, RB, fractal}`

### Важное уточнение для Scenario B (чтобы было однозначно)

Ты написал: “SL за эту трендовую неэффективность”, но в сценарии B вход против тренда.
Фиксируем правило так (MVP), чтобы не было двусмысленности:

* Для **контртрендовой сделки** SL ставится **за H1 элемент, от которого мы торгуем разворот** (тот самый “противоположный”/новообразованный контртрендовый RB/SNR/FVG).
  То есть “эта трендовая неэффективность” в тексте сценария B трактуется как “ключевой H1 элемент, который является причиной входа”.

(Если ты реально хотел SL за трендовый элемент из Scenario A — это можно сделать как параметр `sl_anchor = entry_anchor | trend_inefficiency`, но для MVP лучше один вариант.)

---

## 5) Детект “взаимодействия цены” с H1 элементом

Для любых зон H1 (FVG/SNR/RB) взаимодействие фиксируется, если:

* `price` (или диапазон текущей M5 свечи) пересекает зону.

**Правило (MVP):**

* взаимодействие есть, если `m5_bar.low <= zone_high` и `m5_bar.high >= zone_low`

Для фрактала (линия), взаимодействие:

* `m5_bar.low <= fractal_price <= m5_bar.high`

---

## 6) Правило SL (Stop Loss)

## 6.1. SL якорь (anchor)

SL всегда ставится “за” H1-элемент-основание входа:

* Для Scenario A: anchor = выбранная **трендовая неэффективность** (H1 FVG/SNR)
* Для Scenario B: anchor = **контртрендовый H1 элемент**, который сформировался и дал реакцию (H1 RB/SNR/FVG)

## 6.2. “За зону” (без буфера, MVP)

* Для **long**:

  * если anchor — зона: `SL = anchor.low`
  * если anchor — фрактал/линия: `SL = fractal_price`
* Для **short**:

  * если anchor — зона: `SL = anchor.high`
  * если anchor — фрактал/линия: `SL = fractal_price`

*(Буфер/тик-сайз можно добавить позже как параметр.)*

---

## 7) Правило TP (Take Profit) — ближайший H1 элемент

TP выбирается как **ближайший** по цене (в направлении сделки) из множества H1 элементов:

* `FVG`, `SNR`, `RB`, `fractal`

### 7.1. Определение “ближайший”

Для **long**:

* кандидаты должны быть **выше текущей цены/entry**
* расстояние = `candidate_level - entry_price`
* выбираем минимальное положительное расстояние

Для **short**:

* кандидаты должны быть **ниже entry**
* расстояние = `entry_price - candidate_level`
* выбираем минимальное положительное

### 7.2. Что такое “candidate_level” для разных типов

* FVG/SNR/RB (зона):

  * для long: `candidate_level = zone_low` (первая граница, до которой цена дойдёт)
  * для short: `candidate_level = zone_high`
* fractal (линия):

  * `candidate_level = fractal_price`

### 7.3. Ограничение из твоего требования

> “Берется ближайший FVG/SNR/RB h1 для предложжения сделки”

Фиксируем так:

* Приоритетно для TP выбирать **из H1 зон FVG/SNR/RB**, а **fractal** использовать только если зон нет (или как fallback).
* Это делаем параметром:

  * `tp_prefer_zones = true`

---

## 8) Формирование предложения сделки (Scenario object)

## 8.1. Где хранить

Все взаимодействия и сценарии сохраняются в `Exchange`.

Пути:

* `Exchange/Scenarios/<SYMBOL>.json` — активные и исторические сценарии
* `Exchange/Interactions/<SYMBOL>.jsonl` — (опционально) журнал событий “touch/confirm/created/expired”

## 8.2. Формат сценария (минимум)

```json id="y1r4t4"
{
  "scenario_id": "hash...",
  "symbol": "SPX500",
  "created_at_utc": "...",
  "updated_at_utc": "...",

  "trend_at_creation": "bullish|bearish",
  "scenario_type": "trend_continuation|reversal_at_opposite",

  "direction": "long|short",
  "status": "pending|approved|rejected|expired|cancelled",

  "htf_anchor": {
    "type": "h1_fvg|h1_snr|h1_rb",
    "element_id": "...",
    "zone": [low, high],
    "signal_time_utc": "..."
  },

  "ltf_confirmation": {
    "type": "m5_fvg|m5_snr",
    "element_id": "...",
    "signal_time_utc": "..."
  },

  "entry": {
    "type": "market|limit_zone",
    "price": 0,
    "zone": [a,b]
  },
  "sl": { "price": 0, "rule": "behind_anchor" },
  "tp": { "price": 0, "target_element": { "type": "...", "id": "..." } },

  "evidence_ids": ["..."],

  "expires_at_utc": "...",
  "metadata": {}
}
```

### 8.3. ID сценария (стабильность)

`scenario_id = sha1(symbol|scenario_type|direction|htf_anchor.element_id|ltf_confirmation.element_id|entry.zone|sl|tp)`

Чтобы бот не создавал одно и то же предложение каждую минуту.

---

## 9) Жизненный цикл и взаимодействия трейдера

### 9.1. Статусы

* `pending` — предложено, ждёт решения трейдера
* `approved` — трейдер одобрил
* `rejected` — отклонил
* `expired` — условия устарели (например anchor invalidated / прошло N часов)
* `cancelled` — отменено системой (например конфликт условий)

### 9.2. Хранение решений (как ты требуешь)

Решения трейдера сохраняются в `Exchange`, например:

* `Exchange/Decisions/<SYMBOL>.jsonl` (append-only)
  или
* `Exchange/Decisions/<scenario_id>.json`

(Выбрать один вариант; JSONL удобнее как журнал.)

---

## 10) Триггеры генерации сценариев (когда “думать”)

Модуль сценариев запускается при изменениях:

* обновился `State/<SYMBOL>.json` по H1 (появились/изменились H1 элементы)
* обновился `State/<SYMBOL>.json` по M5 (появились/изменились M5 элементы)
* обновился `Trend/<SYMBOL>.json`

MVP можно делать раз в минуту/по событию записи файла.

---

## 11) Критерии готовности (Acceptance Criteria)

1. Для символа с `trend=bullish`:

   * если цена вошла в H1 bullish FVG или H1 support SNR,
   * и на M5 появилось bullish подтверждение (FVG/SNR),
     → создаётся `pending` сценарий long, с SL за H1 anchor и TP по ближайшему H1 zone.
2. Аналогично для bearish.
3. Scenario B (reversal):

   * фиксируется достижение opposite H1 элемента,
   * затем появление контртрендового H1 RB/SNR/FVG,
   * затем M5 контртренд подтверждение,
     → создаётся сценарий против тренда.
4. Сценарии не дублируются при повторных обновлениях (стабильные IDs).
5. Все сценарии и решения сохраняются в `Exchange`.

Ниже — расширение ТЗ: добавляем **режим бэктеста (event-driven replay)**, где Speculator “накидывает предложения” **так, как делал бы в реальном времени**, без использования будущих баров/элементов. Я сохраняю твою модель (H1 trend inefficiencies + M5 confirm + SL/TP), но добавляю строгие правила “no lookahead”.

---

# Дополнение к ТЗ: Backtest / Replay режим (без lookahead)

## 13) Цель бэктеста

Дать возможность запустить Speculator **с заданной даты/времени** и прогнать модель так, чтобы бот:

* последовательно “видел” рынок бар за баром,
* формировал элементы (FVG/SNR/RB/fractals) только когда они **становятся известны**,
* определял тренд только на основании уже сформированных H1 элементов,
* создавал сценарии только при выполнении условий на текущем шаге,
* **не использовал данные будущих свечей**, включая:

  * будущие экстремумы,
  * будущие статусы (invalidated/mitigated),
  * будущие элементы,
  * будущие “ближайшие цели”, если они ещё не сформированы к этому времени.

---

# 14) Архитектура бэктеста: Event-driven Replay

## 14.1. Режимы

Добавить в Speculator режим запуска:

* `mode = live | backtest`

## 14.2. Входные параметры backtest

* `symbol` (или список)
* `start_time_utc` (обяз.)
* `end_time_utc` (опц., иначе до “сейчас”/до конца истории)
* `timeframes = {H1, M5}` (MVP: только эти 2, позже расширим)
* `warmup_bars` (например: 500 M5 баров до start для корректного формирования первых элементов)
* `output_run_id` (чтобы не смешивать результаты разных прогонов)

---

# 15) Источник данных для backtest

Два варианта (выбрать один как MVP):

### Вариант A (рекомендуемый): прямой доступ к истории MT5

* Speculator в backtest сам загружает историю:

  * M5 бары на диапазон `[start - warmup, end]`
  * H1 бары на диапазон `[start - warmup, end]`

### Вариант B: из предварительно сохранённых файлов

* `Exchange/History/<symbol>/<tf>.csv|parquet`
* полезно для скорости и повторяемости.

---

# 16) Правила “когда элемент считается известным” (No-lookahead)

Это критично, иначе бэктест будет читерским.

## 16.1. FVG

FVG формируется по 3 свечам `C1,C2,C3`.
Он **становится известен** только после закрытия `C3`.

* `known_time_utc = c3_time_utc` (close C3 / время бара C3)

## 16.2. 3-свечной фрактал

Фрактал на `C2` подтверждается закрытием `C3`.

* `known_time_utc = c3_time_utc`

## 16.3. RB

RB строится из `L` и `extreme` фрактала ⇒ RB известен тогда же, когда известен фрактал.

* `known_time_utc = fractal.confirm_time_utc`

## 16.4. SNR

SNR “активируется” на событии break+close, то есть известен на баре `break_time_utc` (закрытие бара пробоя).

* `known_time_utc = break_time_utc`

### Важное: departure-экстремум без заглядывания в будущее

Departure-экстремум считается **на окне**, которое заканчивается `break_time_utc` (или бар перед ним, если ты так решил).
Никаких данных после break бара.

---

# 17) Как строить “State” в backtest

В бэктесте `State` становится не “снимком за весь месяц”, а **инкрементально обновляемым состоянием на момент t**.

## 17.1. In-memory state

Speculator держит структуру:

* `state[t].timeframes.H1.elements.*`
* `state[t].timeframes.M5.elements.*`
* `trend[t]`

Но в файл писать можно:

* либо снапшоты по шагам (дорого),
* либо только события (рекомендуется).

---

# 18) Событийный журнал (для backtest outputs)

## 18.1. Что писать в Exchange

Результаты бэктеста не должны мешаться с live.

Путь:

* `Exchange/Backtests/<run_id>/`

Внутри:

* `proposals.jsonl` — все предложения сценариев по мере генерации
* `events.jsonl` — элементы/тренд/триггеры (для дебага)
* `summary.json` — агрегаты (кол-во сценариев, по типам, по направлениям)

## 18.2. Формат proposals.jsonl

Каждая строка — сценарий в момент создания:

```json id="1g6h6c"
{
  "run_id": "SPX500_2026-01-01_to_2026-02-01",
  "created_at_utc": "2026-01-20T16:05:00Z",
  "symbol": "SPX500",
  "scenario_id": "...",
  "scenario_type": "trend_continuation",
  "direction": "short",
  "trend_at_creation": "bearish",
  "htf_anchor_id": "snr:...",
  "ltf_confirmation_id": "m5_fvg:...",
  "entry": { "type": "market", "price": 6868.5 },
  "sl": { "price": 6880.1 },
  "tp": { "price": 6819.5, "target_id": "h1_rb:..." }
}
```

---

# 19) Алгоритм Replay (пошаговый)

## 19.1. Шаг времени

MVP: основной шаг = **закрытие каждой M5 свечи**.

На каждом `t = close_time(m5_bar)`:

1. **обновить M5 элементы**, которые становятся известны на этом баре:

   * новые M5 FVG
   * новые M5 SNR (если SNR ты тоже строишь на M5)
2. если `t` совпадает с закрытием H1 бара:

   * обновить H1 элементы (FVG/RB/SNR/fractals) **только на основе доступных баров**
   * пересчитать `trend[t]` по H1 FVG/SNR (RB игнорируется для тренда)
3. проверить условия Scenario A и Scenario B (по состоянию на t)
4. если выполнены — создать proposal (pending) и записать в `proposals.jsonl`

### Важно: “без оглядки на будущее”

При расчёте TP “до ближайшего H1 элемента”:

* можно использовать только элементы, у которых `known_time_utc <= t`
* нельзя выбирать цель, которая сформируется через 3 часа.

---

# 20) Выбор TP в backtest (без lookahead)

Правило из live сохраняется, но с ограничением:

* target candidates = H1 {FVG,SNR,RB,fractal} **известные на момент t**

Если кандидатов нет:

* сценарий всё равно может быть создан, но с `tp = null` и статусом `incomplete`,
* либо пропускать (выбрать поведение параметром `require_tp = true|false`).

---

# 21) Экспирация и дедуп в backtest

Чтобы бот не создавал одинаковые предложения на каждом баре:

* `scenario_id` должен быть стабильным (как в live)
* хранить “активные pending” сценарии в памяти
* не создавать новый, если уже есть pending с тем же `scenario_id` и он ещё не expired.

Экспирация (MVP):

* `expires_at_utc = created_at + N часов` (например 12h)
  или
* истёк, если якорный элемент (anchor) стал `invalidated/mitigated_full` **после момента t** (но это будет видно только когда это случится, без будущего).

---

# 22) Acceptance criteria для backtest

1. При одинаковых входных данных прогон даёт **одинаковый** `proposals.jsonl`.
2. Никакой proposal не использует элемент, у которого `known_time_utc > created_at_utc`.
3. Для FVG/fractals/RB/SNR соблюдены правила “когда они становятся известны”.
4. TP выбирается только из “известных” на момент t H1 элементов.
5. Результаты backtest отделены по `run_id` в `Exchange/Backtests/`.

