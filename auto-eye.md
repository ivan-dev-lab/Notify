## Определение FVG, которое будем использовать (ICT/SMC-стандарт)

Берём **3 последовательные свечи**: `C1, C2, C3`.

### Bullish FVG (вверх)

Формируется, если есть “проскок” вверх:

* `High(C1) < Low(C3)`

Тогда **ценовой гэп (зона FVG)**:

* `FVG_low  = High(C1)`
* `FVG_high = Low(C3)`

FVG считается **сформированным** после закрытия `C3`.

### Bearish FVG (вниз)

Формируется, если есть “проскок” вниз:

* `Low(C1) > High(C3)`

Зона:

* `FVG_low  = High(C3)`
* `FVG_high = Low(C1)`

---

## Как “по ценам” считать FVG технически

### 1) Входные данные

Для каждого символа и таймфрейма нужен массив баров:

* `time, open, high, low, close` (volume опционально)

### 2) Базовый детектор (без фильтров)

Идём по барам `i = 2..N-1` и смотрим тройку:

* `C1 = bars[i-2]`
* `C2 = bars[i-1]`
* `C3 = bars[i]`

Условия:

* **Bullish**: `C1.high < C3.low`

  * gap = `[C1.high, C3.low]`
* **Bearish**: `C1.low > C3.high`

  * gap = `[C3.high, C1.low]`

**Размер гэпа**:

* `gap_size = FVG_high - FVG_low`


## Как отслеживать “сформированные” и их статус (mitigation/fill)

Тут важно определить правила.

### Статусы

* `formed` — сформирован (после C3 close)
* `touched` — цена зашла внутрь зоны хотя бы 1 тик/бар
* `mitigated_partial` — частично заполнен (есть проникновение)
* `mitigated_full` — полностью заполнен (цена прошла через всю зону)

### Логика заполнения (простая по барам)

Для **bullish FVG** (зона `[low, high]`):

* “touch” если у будущего бара `low <= FVG_high` и `high >= FVG_low` (пересечение диапазонов)
* **полное заполнение** (строго): если у будущего бара `low <= FVG_low`

  * (то есть цена дошла до нижней границы зоны или ниже)

Для **bearish FVG**:

* touch аналогично по пересечению
* **полное заполнение**: если `high >= FVG_high`

> Если хочешь “профессионально”, можно считать **процент заполнения** (penetration), но для старта достаточно touch/full.

---

# Задание (ТЗ) на реализацию FVG-детектора и обновление истории за месяц

## Цель

Сделать модуль, который:

1. **Загружает/обновляет историю** за последние ~30 дней по символу и таймфрейму из MT5
2. **Находит все сформированные FVG**
3. **Ведёт статус** (active/mitigated) при появлении новых баров
4. Отдаёт результат в удобном виде (JSON/CSV/в память для GUI)

---

## Требования к данным

* Источник: MT5 (Python `MetaTrader5`)
* История: **последние 35 дней** (30 + буфер 5)
* Таймфрейм: параметр `TIMEFRAME_M5` (или любой)
* Обновление: раз в 5 минут (у тебя так)

---

## Выходные данные (структура FVG)

Для каждого FVG записывать:

* `id` (например hash по symbol+tf+formation_time+bounds)
* `symbol`, `timeframe`
* `direction` = `bullish|bearish`
* `formation_time` = время свечи `C3`
* `fvg_low`, `fvg_high`, `gap_size`
* `c1_time`, `c2_time`, `c3_time` (для отладки)
* `status` = `active|touched|mitigated_full`
* `touched_time` (если был touch)
* `mitigated_time` (если fully filled)
* (опционально) `fill_price` / `fill_percent`

---

## Алгоритм обработки

### A) Первичная загрузка

1. `copy_rates_range(symbol, tf, now-35d, now)`
2. Сортировка по времени
3. Прогон детектора FVG по всей истории
4. Для каждого найденного FVG пройти вперёд по будущим барам и определить статус:

   * если fully filled → `mitigated_full`
   * иначе если был touch → `touched`
   * иначе `active`

### B) Инкрементальное обновление каждые 5 минут

1. Догрузить последние N баров (например последние 500) или `copy_rates_from_pos` с конца
2. Обновить/добавить новые FVG, которые могли появиться только на последних 3 барах
3. Для активных FVG обновить статус по новым барам

---

## Параметры (конфиг)

* `min_gap_points`
* `require_displacement` (bool)
* `displacement_k` (например 1.5)
* `atr_period` или `median_body_period`
* `fill_rule`: `touch`/`full`/`both`

---

## Acceptance criteria (критерии готовности)

* На синтетических тест-кейсах:

  * bullish FVG находится ровно при `High(C1) < Low(C3)`
  * bearish FVG находится ровно при `Low(C1) > High(C3)`
  * статус `mitigated_full` выставляется корректно по правилу fill
* На реальных данных:

  * модуль стабильно обновляется без перезагрузки MT5
  * количество FVG не “дублируется” при каждом апдейте (устойчивый `id`)
* Экспорт результата в `CSV/JSON` работает

---

## Псевдокод детектора

```text
for i in range(2, N):
  C1 = bars[i-2]; C2 = bars[i-1]; C3 = bars[i]

  if C1.high < C3.low:
     low = C1.high
     high = C3.low
     if high-low >= min_gap: create bullish FVG at time C3.time

  if C1.low > C3.high:
     low = C3.high
     high = C1.low
     if high-low >= min_gap: create bearish FVG at time C3.time
```

---